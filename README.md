# 学习Java语言

    1.HashMap源码学习
        1.低层使用数组和链表加1.8版本出的红黑树, 当有hash冲突时链表长度在大于等于8时链表会转成红黑树来存储
        2.最理想的数据均匀扩散不产生链表
        3.红黑树查找是O(logn)链表查找O(n)
        4.为什么初始容量是要2的指数次幂? 为了运算效率; 因为在使用二进制计算数组索引时有使用&(位与)运算符, 2的次幂-1后, 一定得到
    的是小于数组的length-1;hash & length-1
        5.为什么加载因子是0.75? 为了时间利用率和空间利用率的最优平衡, 泊松分布的统计学算法得到的,链表8变红黑树,加载因子为0.75;
    16 * 0.75 = 12, 12为扩充的时机, 如果为1那么16才扩容, 扩容过晚, 冲突几率高, 加载因子为0.5, 过早扩容, 浪费时间;
        6.hash死锁: 发生在2个线程同时put数据, 数组扩容时, 链表同时反转,就会形成循环链表. get时就会发生死循环
        7.put源码: 检测数组是否初始化过, 未初始化过, 容量设置为2的次幂, 计算key的hash值, 计算key的数组索引, 判断hash是否一致
    hash一致, 判断key的equals, 一致就覆盖其value, 否则把当前添加的数据作为链表的第一个节点; hash不一致添加一个新的entry
        
    2.Java虚拟机
        Java虚拟机执行字节码.class文件, Java->class->机器码, 机器码可以操作系统和硬件; Java虚拟机JVM可以在不同平台运行, 然后解释成不同
    平台的机器码
        
        
# Javac 把Java编译成class文件
 
 用法: javac <options> <source files> //直接Javac 加源文件绝对路径,就会在源文件同目录生成对应的class文件
其中, 可能的选项包括:
  -g                         生成所有调试信息
  -g:none                    不生成任何调试信息
  -g:{lines,vars,source}     只生成某些调试信息
  -nowarn                    不生成任何警告
  -verbose                   输出有关编译器正在执行的操作的消息
  -deprecation               输出使用已过时的 API 的源位置
  -classpath <路径>            指定查找用户类文件和注释处理程序的位置
  -cp <路径>                   指定查找用户类文件和注释处理程序的位置
  -sourcepath <路径>           指定查找输入源文件的位置
  -bootclasspath <路径>        覆盖引导类文件的位置
  -extdirs <目录>              覆盖所安装扩展的位置
  -endorseddirs <目录>         覆盖签名的标准路径的位置
  -proc:{none,only}          控制是否执行注释处理和/或编译。
  -processor <class1>[,<class2>,<class3>...] 要运行的注释处理程序的名称; 绕过默认的搜索进程
  -processorpath <路径>        指定查找注释处理程序的位置
  -d <目录>                    指定放置生成的类文件的位置
  -s <目录>                    指定放置生成的源文件的位置
  -implicit:{none,class}     指定是否为隐式引用文件生成类文件
  -encoding <编码>             指定源文件使用的字符编码
  -source <发行版>              提供与指定发行版的源兼容性
  -target <发行版>              生成特定 VM 版本的类文件
  -version                   版本信息
  -help                      输出标准选项的提要
  -A关键字[=值]                  传递给注释处理程序的选项
  -X                         输出非标准选项的提要
  -J<标记>                     直接将 <标记> 传递给运行时系统
  -Werror                    出现警告时终止编译
  @<文件名>                     从文件读取选项和文件名

    
# Reference + ReferenceQueue

当我们想检测一个对象是否被回收了，那么我们就可以采用 Reference + ReferenceQueue，大概需要几个步骤：

创建一个引用队列 queue
创建 Refrence 对象，并关联引用队列 queue
在 reference 被回收的时候，refrence 会被添加到 queue 中

